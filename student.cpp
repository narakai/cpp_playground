//
// Created by lai leon on 2021/12/7.
//

#include "student.h"

//在C++中 struct和class唯一的区别就在于 默认的访问权限不同
//struct 默认权限为公共
//class 默认权限为私有

//构造函数语法：类名(){}
//
//构造函数，没有返回值也不写void
//        函数名称与类名相同
//构造函数可以有参数，因此可以发生重载
//        程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次
//        析构函数语法： ~类名(){}
//
//析构函数，没有返回值也不写void
//        函数名称与类名相同,在名称前加上符号 ~
//析构函数不可以有参数，因此不可以发生重载
//        程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次

////无参（默认）构造函数
//Person() {
//    cout << "无参构造函数!" << endl;
//}
////有参构造函数
//Person(int a) {
//    age = a;
//    cout << "有参构造函数!" << endl;
//}
////拷贝构造函数
//Person(const Person& p) {
//    age = p.age;
//    cout << "拷贝构造函数!" << endl;
//}
////析构函数
//~Person() {
//    cout << "析构函数!" << endl;
//}

//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反

//
//多态满足条件：
//1、有继承关系
//2、子类重写父类中的虚函数
//多态使用：
//父类指针或引用指向子类对象

class Animal {
public:
    //Speak函数就是虚函数
    //函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。
    virtual void speak() {
        cout << "动物在说话" << endl;
    }
};

class Cat : public Animal {
public:
    void speak() {
        cout << "小猫在说话" << endl;
    }
};

//​ 1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象
//
//​ 2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构
//
//​ 3. 拥有纯虚析构函数的类也属于抽象类

//int main() {
//
//    Student stu;
//    stu.setName("德玛西亚");
//    stu.setID(250);
//    stu.showStudent();
//
//    return 0;
//}